---
title: 'Taming 30 Repos: Building Local Dev Tooling for a Poly-Repo Setup'
description: 'When your architecture spans 30+ repositories, onboarding becomes painful. Here is how we built a simple CLI tool to clone and sync everything in one command.'
date: 2026-01-08
image: './banner.jpg'
tags: ['tooling', 'bun', 'developer-experience', 'poly-repo']
authors: ['thilina-rathnakumara']
---

Picture this: someone new joins the team. We send them the GitHub org link. 30+ repositories stare back at them.

"Just clone the ones you need," we say.

Which ones? Good question. We didn't have a great answer.

## The Problem

Our architecture is distributed across 9 core services, supporting services, three frontend clients, SDKs, infrastructure configs, and docs. Each repo has its own package manager and setup quirks.

The previous onboarding experience: clone a repo, cd into it, run install, cd out, repeat. Oh wait, this one uses pnpm not bun. And this other one needs husky initialized. Repeat 27 more times.

Nobody actually did this. We'd clone 3-4 repos and never touch the rest. None of us really understood how all the pieces fit together.

## The Solution

We built [local-dev](https://github.com/CROW-B3/local-dev) - a tiny CLI that clones and syncs everything:

```bash
bun run clone    # Clones 22 default repos with dependencies installed
bun run sync     # Pulls latest on all repos (skips dirty ones)
```

That's it. Two commands.

## Why Bun?

We needed something fast and cross-platform. Bun's shell API was perfect:

- **Speed**: `bun install` is ~10x faster than npm. Across 22 repos, that adds up.
- **Cross-platform**: Same script works on Linux, macOS, and Windows.
- **Concurrency**: Bun shell runs operations concurrently by default.

The `$` template literal in Bun is a [complete shell reimplementation](https://bun.sh/blog/the-bun-shell) - not just syntactic sugar over child processes.

## How It Works

**Categorized repos**: Not all repos are equal. Core services, clients, and SDKs clone by default. Templates and R&D repos don't.

```bash
bun run clone                           # 22 default repos
bun run clone --all                     # All 30 repos
bun run clone --only core-auth-service  # Just one
```

**Smart package manager detection**: Looks for lock files and picks the right tool. `bun.lock` → bun, `pnpm-lock.yaml` → pnpm, etc.

**Safe syncing**: Dirty repos get skipped by default. Use `--force` to stash changes first.

**Auto husky setup**: Git hooks get initialized automatically so pre-commit hooks actually run.

## The Output

We made the output readable:

```
[INFO] Repositories: 22

> core-api-gateway [OK]
> dashboard-client [OK]
> rogue-store [SKIP] Already exists

────────────────────────────────────
  SUMMARY
────────────────────────────────────
+ Success: 19
! Skipped: 2
x Failed: 1
```

## What We Skipped

**Parallel cloning**: GitHub rate limits make sequential faster in practice.

**Monorepo migration**: Would be "right" but too much work. The local-dev tool is pragmatic.

**Watch mode**: Nobody wants repos randomly updating while working.

## Conclusion

~200 lines of TypeScript. Took an afternoon to build, saves everyone hours over time.

Check out the [local-dev repo](https://github.com/CROW-B3/local-dev) if you want to see the implementation.
